"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1183],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||i;return n?r.createElement(g,a(a({ref:t},c),{},{components:n})):r.createElement(g,a({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var p=2;p<i;p++)a[p]=n[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3444:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=n(7462),o=(n(7294),n(3905));const i={id:"regions",title:"Defining Regions"},a=void 0,s={unversionedId:"guides/xml-pointers/regions",id:"guides/xml-pointers/regions",title:"Defining Regions",description:"First of all, region coordinates in PGM are real numbers.",source:"@site/docs/guides/xml-pointers/regions.mdx",sourceDirName:"guides/xml-pointers",slug:"/guides/xml-pointers/regions",permalink:"/docs/guides/xml-pointers/regions",draft:!1,editUrl:"https://github.com/PGMDev/Website/tree/master/src/docs/guides/xml-pointers/regions.mdx",tags:[],version:"current",frontMatter:{id:"regions",title:"Defining Regions"},sidebar:"Guides",next:{title:"Using Filters and Regions",permalink:"/docs/guides/xml-pointers/applying-to-regions"}},l={},p=[{value:"Regions: The Wrong Way",id:"regions-the-wrong-way",level:3}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"First of all, region coordinates in PGM are ",(0,o.kt)("em",{parentName:"p"},"real numbers"),".\nThat means they can be fractional values, like ",(0,o.kt)("inlineCode",{parentName:"p"},"2.3"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"4.5"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"6.789"),", and so on.\nA coordinate represents a ",(0,o.kt)("em",{parentName:"p"},"point")," on one of the three axes (X, Y, or Z), and a set of three coordinates represents a ",(0,o.kt)("em",{parentName:"p"},"point")," in 3D space.\nCoordinates do ",(0,o.kt)("strong",{parentName:"p"},"not")," represent blocks, at least not ",(0,o.kt)("em",{parentName:"p"},"directly"),".\nWhen PGM needs to decide if a block is inside a region, it checks if the point at the ",(0,o.kt)("strong",{parentName:"p"},"center")," of the block is inside the region.\nThe center point of a block will always have coordinates that end in ",(0,o.kt)("inlineCode",{parentName:"p"},"0.5"),".\nWhen making regions, you have to make sure that all the block centers are ",(0,o.kt)("em",{parentName:"p"},"inside")," the region."),(0,o.kt)("p",null,"Here is an example. Let's say we want to make region for a destroyable that looks like this:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/q9NMNuV.png",alt:null})),(0,o.kt)("p",null,"First, we stand very close to one ",(0,o.kt)("strong",{parentName:"p"},"corner")," of the region and note the coordinates are ",(0,o.kt)("inlineCode",{parentName:"p"},"(32, 60, -20)"),":"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/OzvGnlJ.png",alt:null})),(0,o.kt)("p",null,"Then we stand over the opposite corner and note the coordinates are ",(0,o.kt)("inlineCode",{parentName:"p"},"(34, 60, -18)"),"."),(0,o.kt)("p",null,"We know the monument is three blocks tall, so we'll just subtract three from the Y coordinate to get ",(0,o.kt)("inlineCode",{parentName:"p"},"(34, 57, -18)"),":"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/mNeLmU8.png",alt:null})),(0,o.kt)("p",null,"Notice that we are rounding to the ",(0,o.kt)("strong",{parentName:"p"},"nearest")," integer, since those will obviously be the coordinates of the corner we are standing close to.\nWe don't need to worry about positive vs negative coordinates, as they work the same way, and we never need to add or subtract one."),(0,o.kt)("p",null,"With these coordinates, we can make a cuboid region for the monument:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-xml"},'<cuboid min="32, 60, -20" max="34, 57, -18"/>\n')),(0,o.kt)("p",null,"For style points, we can make sure all the low coordinates are in min and the high ones in max:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-xml"},'<cuboid min="32, 57, -20" max="34, 60, -18"/>\n')),(0,o.kt)("p",null,"This is not necessary, as PGM will fix it for you, but it might make the XML easier for a human to read and edit."),(0,o.kt)("p",null,"An easy way to check that cuboid regions are correct is to simply subtract the low coordinates from the high ones.\nThe result should be the size of the region. If it isn't, you did something wrong."),(0,o.kt)("p",null,"Let's try a more interesting region: a cylinder.\nA cylinder is defined by its base (center) point, radius, and height.\nAssuming one layer of blocks, the cylinder in the image below is based at ",(0,o.kt)("inlineCode",{parentName:"p"},"(53.5, 57, -10.5)")," and has a radius of ",(0,o.kt)("inlineCode",{parentName:"p"},"2.5")," and a height of ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),".\nBlocks with their center point inside the cylinder will be considered part of the region."),(0,o.kt)("p",null,"The region boundary and the block centers are highlighted so you can easily see how this works:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://i.imgur.com/OgME3KK.png",alt:null})),(0,o.kt)("p",null,"So the region would be:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-xml"},'<cylinder base="53.5, 57, -10.5" radius="2.5" height="1"/>\n')),(0,o.kt)("h3",{id:"regions-the-wrong-way"},"Regions: The Wrong Way"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"DON'T")," use WorldEdit to get region coordinates.\nWorldEdit uses a dumb coordinate system that will not give you correct regions, and while it's possible to convert the coordinates,\nit's going to confuse you and cause mistakes, and it's just not worth the trouble."))}d.isMDXComponent=!0}}]);