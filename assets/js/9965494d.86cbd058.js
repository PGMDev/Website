"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3776],{5647:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>a,frontMatter:()=>s,metadata:()=>d,toc:()=>o});var l=n(5893),i=n(1151);const s={id:"lootables",title:"Lootables"},r=void 0,d={id:"modules/gear/lootables",title:"Lootables",description:"Lootables are chests or other containers that generate their contents based on custom rules and probabilities.",source:"@site/docs/modules/gear/lootables.mdx",sourceDirName:"modules/gear",slug:"/modules/gear/lootables",permalink:"/docs/modules/gear/lootables",draft:!1,unlisted:!1,editUrl:"https://github.com/PGMDev/Website/tree/master/docs/modules/gear/lootables.mdx",tags:[],version:"current",lastUpdatedAt:1724740491e3,frontMatter:{id:"lootables",title:"Lootables"},sidebar:"docs",previous:{title:"Kill Rewards",permalink:"/docs/modules/gear/kill-rewards"},next:{title:"Block Drops",permalink:"/docs/modules/blocks/blockdrops"}},c={},o=[{value:"Loot",id:"loot",level:2},{value:"Loot Element",id:"loot-element",level:4},{value:"Loot Attributes",id:"loot-attributes",level:4},{value:"Loot Sub-elements",id:"loot-sub-elements",level:4},{value:"Random Selection",id:"random-selection",level:3},{value:"Any Attributes",id:"any-attributes",level:4},{value:"Any Sub-elements",id:"any-sub-elements",level:4},{value:"Option Attributes",id:"option-attributes",level:4},{value:"Conditional Inclusion",id:"conditional-inclusion",level:3},{value:"Maybe Attributes",id:"maybe-attributes",level:4},{value:"Container Fill",id:"container-fill",level:2},{value:"Fill Element",id:"fill-element",level:4},{value:"Fill Attributes",id:"fill-attributes",level:4},{value:"Examples",id:"examples",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.a)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.p,{children:"Lootables are chests or other containers that generate their contents based on custom rules and probabilities.\nThey can optionally refill themselves on a schedule or in response to dynamic filters."}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{children:"Element"}),(0,l.jsx)(t.th,{children:"Description"})]})}),(0,l.jsx)(t.tbody,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"<lootables> </lootables>"})}),(0,l.jsx)(t.td,{children:"A procedural list of loot."})]})})]}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{children:"Sub-elements"}),(0,l.jsx)(t.th,{}),(0,l.jsx)(t.th,{children:"Value/Children"})]})}),(0,l.jsxs)(t.tbody,{children:[(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"<loot> </loot>"})}),(0,l.jsx)(t.td,{children:"A generated set of items."}),(0,l.jsx)(t.td,{children:(0,l.jsx)("span",{className:"badge badge--secondary",children:"Loot Sub-elements"})})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"<fill> </fill>"})}),(0,l.jsx)(t.td,{children:"Configuration for filling containers with loot."}),(0,l.jsx)(t.td,{children:(0,l.jsx)("span",{className:"badge badge--secondary",children:"Fill Sub-elements"})})]})]})]}),"\n",(0,l.jsx)(t.h2,{id:"loot",children:"Loot"}),"\n",(0,l.jsxs)(t.p,{children:["The ",(0,l.jsx)(t.code,{children:"<loot>"})," element defines a generated set of items, using literal ",(0,l.jsx)(t.code,{children:"<item>"})," elements, and operations for choosing them."]}),"\n",(0,l.jsx)(t.h4,{id:"loot-element",children:"Loot Element"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{children:"Element"}),(0,l.jsx)(t.th,{children:"Description"}),(0,l.jsx)(t.th,{children:"Value/Children"})]})}),(0,l.jsx)(t.tbody,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"<loot>"})}),(0,l.jsx)(t.td,{children:"A generated set of items."}),(0,l.jsx)(t.td,{children:(0,l.jsx)("span",{className:"badge badge--secondary",children:"Loot Sub-elements"})})]})})]}),"\n",(0,l.jsx)(t.h4,{id:"loot-attributes",children:"Loot Attributes"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{children:"Attribute"}),(0,l.jsx)(t.th,{children:"Description"}),(0,l.jsx)(t.th,{children:"Value"})]})}),(0,l.jsx)(t.tbody,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"id"})}),(0,l.jsx)(t.td,{children:"Unique identifier used to reference this loot from other places in the XML."}),(0,l.jsx)(t.td,{children:(0,l.jsx)("span",{className:"badge badge--primary",children:"String"})})]})})]}),"\n",(0,l.jsx)(t.h4,{id:"loot-sub-elements",children:"Loot Sub-elements"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{children:"Element"}),(0,l.jsx)(t.th,{children:"Description"}),(0,l.jsx)(t.th,{children:"Value"})]})}),(0,l.jsxs)(t.tbody,{children:[(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"<item>"})}),(0,l.jsx)(t.td,{children:"An item to include in the loot. This can be any type of item element, and can have any item attributes."}),(0,l.jsx)(t.td,{children:(0,l.jsx)(t.a,{href:"/docs/modules/gear/items",children:"Item"})})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"<any>"})}),(0,l.jsx)(t.td,{children:"A random selection of children."}),(0,l.jsx)(t.td,{})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"<maybe>"})}),(0,l.jsx)(t.td,{children:"Include child conditionally based on a filter."}),(0,l.jsx)(t.td,{})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"<all>"})}),(0,l.jsx)(t.td,{children:"Include all children."}),(0,l.jsx)(t.td,{})]})]})]}),"\n",(0,l.jsx)(t.h3,{id:"random-selection",children:"Random Selection"}),"\n",(0,l.jsxs)(t.p,{children:["The ",(0,l.jsx)(t.code,{children:"<any>"})," element makes a random selection from any number of child elements.\nIts children can be ",(0,l.jsx)(t.code,{children:"<option>"})," elements, or any other ",(0,l.jsx)(t.code,{children:"<loot>"})," sub-element."]}),"\n",(0,l.jsx)(t.h4,{id:"any-attributes",children:"Any Attributes"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{children:"Attribute"}),(0,l.jsx)(t.th,{children:"Description"}),(0,l.jsx)(t.th,{children:"Value"}),(0,l.jsx)(t.th,{children:"Default"})]})}),(0,l.jsxs)(t.tbody,{children:[(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"count"})}),(0,l.jsx)(t.td,{children:"The number of child elements to choose."}),(0,l.jsx)(t.td,{children:(0,l.jsx)("span",{className:"badge badge--primary",children:"Numeric Range"})}),(0,l.jsx)(t.td,{})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"unique"})}),(0,l.jsxs)(t.td,{children:["Set to ",(0,l.jsx)(t.code,{children:"true"})," if each child can only be chosen once.",(0,l.jsx)("br",{}),"Set to ",(0,l.jsx)(t.code,{children:"false"})," to allow a child to be chosen multiple times."]}),(0,l.jsx)(t.td,{children:(0,l.jsx)("span",{className:"badge badge--primary",children:"true/false"})}),(0,l.jsx)(t.td,{children:"true"})]})]})]}),"\n",(0,l.jsx)(t.h4,{id:"any-sub-elements",children:"Any Sub-elements"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{children:"Element"}),(0,l.jsx)(t.th,{children:"Description"})]})}),(0,l.jsx)(t.tbody,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"<option>"})}),(0,l.jsx)(t.td,{children:"A single option for the random selection."})]})})]}),"\n",(0,l.jsx)(t.h4,{id:"option-attributes",children:"Option Attributes"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{children:"Attribute"}),(0,l.jsx)(t.th,{children:"Description"}),(0,l.jsx)(t.th,{children:"Value"}),(0,l.jsx)(t.th,{children:"Default"})]})}),(0,l.jsxs)(t.tbody,{children:[(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"weight"})}),(0,l.jsx)(t.td,{children:"The weight of this option relative to all others."}),(0,l.jsx)(t.td,{children:(0,l.jsx)("span",{className:"badge badge--primary",children:"Number"})}),(0,l.jsx)(t.td,{children:"1"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"filter"})}),(0,l.jsx)(t.td,{children:"Filter used to decide the eligibility of this option."}),(0,l.jsx)(t.td,{children:(0,l.jsx)(t.a,{href:"/docs/modules/mechanics/filters",children:"Filter"})}),(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"always"})})]})]})]}),"\n",(0,l.jsx)(t.h3,{id:"conditional-inclusion",children:"Conditional Inclusion"}),"\n",(0,l.jsxs)(t.p,{children:["The ",(0,l.jsx)(t.code,{children:"<maybe>"})," element includes its child elements only if the specified filter matches.\nThe filter is matched against the first player to access the loot."]}),"\n",(0,l.jsx)(t.h4,{id:"maybe-attributes",children:"Maybe Attributes"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{children:"Attribute"}),(0,l.jsx)(t.th,{children:"Description"}),(0,l.jsx)(t.th,{children:"Value"})]})}),(0,l.jsx)(t.tbody,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"filter"})}),(0,l.jsx)(t.td,{children:"Filter used to decide inclusion of children."}),(0,l.jsx)(t.td,{children:(0,l.jsx)(t.a,{href:"/docs/modules/mechanics/filters",children:"Filter"})})]})})]}),"\n",(0,l.jsx)(t.h2,{id:"container-fill",children:"Container Fill"}),"\n",(0,l.jsxs)(t.p,{children:["The ",(0,l.jsx)(t.code,{children:"<fill>"})," element fills containers with generated loot.\nIt will fill ",(0,l.jsx)(t.strong,{children:"anything"})," that has an inventory, and matches its ",(0,l.jsx)(t.code,{children:"filter"})," property.\nThis can include chests, dispensers, storage minecarts, or any other container block or entity.\nIt will fill containers regardless of where they came from, so if you don't want player-placed\nchests to be filled, you will need to use ",(0,l.jsx)(t.a,{href:"/docs/modules/mechanics/filters#spatial-filters",children:"blocks filter"}),"."]}),"\n",(0,l.jsx)(t.h4,{id:"fill-element",children:"Fill Element"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{children:"Element"}),(0,l.jsx)(t.th,{children:"Description"})]})}),(0,l.jsx)(t.tbody,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"<fill>"})}),(0,l.jsx)(t.td,{children:"Automatically fills containers with loot."})]})})]}),"\n",(0,l.jsx)(t.h4,{id:"fill-attributes",children:"Fill Attributes"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{children:"Attribute"}),(0,l.jsx)(t.th,{children:"Description"}),(0,l.jsx)(t.th,{children:"Value"}),(0,l.jsx)(t.th,{children:"Default"})]})}),(0,l.jsxs)(t.tbody,{children:[(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"loot"})}),(0,l.jsx)(t.td,{children:"Loot to fill containers with."}),(0,l.jsx)(t.td,{children:(0,l.jsx)("span",{className:"badge badge--primary",children:"Loot"})}),(0,l.jsx)(t.td,{})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"filter"})}),(0,l.jsx)(t.td,{children:"Selects which blocks/entities to fill."}),(0,l.jsx)(t.td,{children:(0,l.jsx)(t.a,{href:"/docs/modules/mechanics/filters",children:"Filter"})}),(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"always"})})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"refill-trigger"})}),(0,l.jsx)(t.td,{children:"Optional dynamic filter that causes containers to be refilled."}),(0,l.jsx)(t.td,{children:(0,l.jsx)(t.a,{href:"/docs/modules/mechanics/filters#dynamic-filters",children:"Dynamic Filter"})}),(0,l.jsx)(t.td,{})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"refill-interval"})}),(0,l.jsx)(t.td,{children:"Time to refill containers after they are first accessed."}),(0,l.jsx)(t.td,{children:(0,l.jsx)(t.a,{href:"/docs/reference/misc/time-periods",children:"Time Period"})}),(0,l.jsxs)(t.td,{children:[(0,l.jsx)(t.code,{children:"oo"})," (never)"]})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{children:(0,l.jsx)(t.code,{children:"refill-clear"})}),(0,l.jsx)(t.td,{children:"Whether to clear containers before refilling them."}),(0,l.jsx)(t.td,{children:(0,l.jsx)("span",{className:"badge badge--primary",children:"true/false"})}),(0,l.jsx)(t.td,{children:"true"})]})]})]}),"\n",(0,l.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-xml",children:'<lootables>\n    \x3c!-- Define a procedural list of loot --\x3e\n    \x3c!-- Can be different every time it is used --\x3e\n    \x3c!-- All operators can be composed within each other --\x3e\n    <loot id="stuff">\n        \x3c!-- Always include these items --\x3e\n        <item material="stone sword"/>\n        <item material="bow"/>\n        \x3c!-- Include if filter matches opener of the container --\x3e\n        <maybe filter="red-team">\n            <item material="stained clay" damage="14" amount="64"/>\n            <item material="leather helmet" color="#f00"/>\n        </maybe>\n\n        \x3c!-- Choose one element at random --\x3e\n        <any>\n            <item material="stone" damage="1"/>\n            <item material="stone" damage="2"/>\n            <item material="stone" damage="3"/>\n        </any>\n\n        \x3c!-- Weighted choice --\x3e\n        <any>\n            <option weight="5">\n                <item material="cookie"/>\n            </option>\n            <option weight="3">\n                <item material="bread"/>\n            </option>\n            <option weight="1">\n                <item material="golden apple"/>\n            </option>\n        </any>\n\n        \x3c!-- Choose any two unique elements (unique="false" to allow duplicates) --\x3e\n        <any count="2">\n            ...\n        </any>\n\n        \x3c!-- Choose between 3 and 5 unique elements --\x3e\n        <any count="3..5">\n            ...\n        </any>\n    </loot>\n\n    \x3c!-- Define inventories to refill --\x3e\n    \x3c!-- Filling always happens when a player opens the inventory --\x3e\n    \x3c!-- Any block or entity that has an inventory (and matches the filter) will be filled --\x3e\n    <fill loot="stuff"          \x3c!-- Loot to fill inventory with --\x3e\n          filter="chests"       \x3c!-- Inventories to fill (blocks or entities) --\x3e\n          refill-interval="3s"  \x3c!-- Minimum interval between refills (default +inf) --\x3e\n          refill-trigger="..."  \x3c!-- Dynamic filter to trigger refill (default none) --\x3e\n          refill-clear="true"   \x3c!-- Clear inventory before refilling (default true) --\x3e\n    />\n</lootables>\n'})})]})}function a(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>d,a:()=>r});var l=n(7294);const i={},s=l.createContext(i);function r(e){const t=l.useContext(s);return l.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),l.createElement(s.Provider,{value:t},e.children)}}}]);